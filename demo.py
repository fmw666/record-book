def count_ways(n):
    if n == 1:
        return 1
    
    total_ways = 0
    for i in range(1, n + 1):
        total_ways += count_ways(n - i)
    
    return total_ways

# 测试
print(count_ways(1))  # 输出 1
print(count_ways(2))  # 输出 2
print(count_ways(3))  # 输出 4
print(count_ways(4))  # 输出 8
print(count_ways(5))  # 输出 16

"""
这道题是个典型的排列组合问题，矩形排列有组合方式，矩形内元素也有组合方式。
按照矩形内元素排列填充到矩形排列中，答案就是【矩形排列组合数】*【矩形内元素组合数】

==========
先说矩形内元素的组合方式，以三种为例：
1. 文本 - 图片 - 列表
2. 文本 - 列表 - 图片
3. 图片 - 文本 - 列表
4. 图片 - 列表 - 文本
5. 列表 - 文本 - 图片
6. 列表 - 图片 - 文本

推导为 n 种元素有 n! 种排列方案。
==========

==========
矩形的排列可以抽象为一道数学问题：一个正整数有多少种求和运算方式？
矩形排列元素如果为 3 种，可选排列包括：
1. 3+0（第一排 3 个矩形，第二排没有）
2. 2+1（第一排 2 个矩形，第二排 1 个矩形）
3. 1+2（第一排 1 个矩形，第二排 2 个矩形）
4. 1+1+1（第一排 1 个矩形，第二排 1 个矩形，第三排 1 个矩形）

推导为 n 种矩形有 2^(n-1) 种排列方案。
==========

因此答案就是 n! * 2^(n-1)

1. 总共 3! * 2^(3-1) = 24. 有穷
2. 可以按抽象数学形式来表达对应的数据结构
（如 1+12+2，一共 14 个矩形元素，第一排 1 个矩形，第二排 12 个矩形，第三排 2 个矩形）
（区域按照列表形式进行存储，如：[区域1, 区域2, 区域3, ...]，分别表示从上到下，从左到右的元素位置）
3. 如果按推导，只计算排列方案数，可直接利用结论：n! * 2^(n-1)
（递归或动态规划可求解 dp 结果列表）
"""