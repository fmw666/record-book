# 数据库

## mysql 基础

### Mysql 数据库配置管理是什么？

+ Mysql 数据库配置管理是指 Mysql 数据库的配置文件 my.cnf
+ my.cnf 文件中包含了 Mysql 数据库的配置信息，如：数据库的端口号、数据库的字符集、数据库的存储路径等。
+ 如何管理：可以通过修改 my.cnf 文件来修改 Mysql 数据库的配置信息。

### 什么是事务（Transaction）？

+ 事务是数据库并发控制的基本单位，是用户定义的一个 sql 操作集合，这些操作要么都执行，要么都不执行。
+ 比如转账操作就是典型的事务，A 账户扣钱，B 账户加钱，要么都成功，要么都失败。

### 事务的四个基本特性是什么？

+ 事务的四个基本特性是：ACID，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

+ 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
+ 一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。简单来说就是：事务前后数据的完整性必须保持一致。（一般通过锁机制来实现）
+ 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
+ 持久性（Durability）：持久性也称永久性（Permanence），指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 一致性和原子性的区别是什么？

+ 原子性关注的是状态，要么全部成功，要么全部失败。

+ 一致性关注的是数据，事务前后数据的完整性必须保持一致。并且中间状态对外部不可见。

### 事务不进行并发控制，可能会产生的异常情况有哪些？

+ 会产生四种异常情况，即脏读（Dirty Read）、不可重复读（Non-Repeatable Read）、幻读（Phantom Read）和丢失修改（lost update）。

+ 脏读：一个事务读到了另一个事务未提交的数据。
+ 幻读：一个事务第二次查会出现第一次没有的结果。
+ 非重复读：一个事务重复读两次得到不同的结果。
+ 丢失修改：并发写入造成其中一些修改丢失。

### 为了解决并发控制异常，数据库提供了四种隔离级别，分别是什么？

+ 读未提交（Read Uncommitted）：允许脏读，一个事务可以读取另一个未提交事务的数据。
+ 读已提交（Read Committed）：允许不可重复读，一个事务只能读取另一个已提交事务的数据。
+ 可重复读（Repeatable Read）：允许幻读，一个事务在多次读取同一数据时，读取的数据是一致的。（Mysql InnoDB 默认实现可重复读级别）
+ 串行化（Serializable）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，但是这种方式效率低下，比较耗数据库性能，一般不使用。

### 如何解决高并发场景下的插入重复

+ 在未使用分库分表的情况下，可以使用唯一索引来解决，但是这样会导致大量的重试，影响性能。
+ 使用异步队列来处理，比如分布式消息队列 kafka，将数据写入到 kafka 中，然后消费 kafka 中的数据写入到数据库中，这样就可以保证数据不会重复。
+ 使用 redis 等实现分布式锁，保证同一时间只有一个线程可以写入数据。

### 常用的锁有哪些

+ 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
+ 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
+ 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
+ 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。
+ 记录锁（Record Lock）：在索引记录上的锁，锁定一条记录。
+ 间隙锁（Gap Lock）：锁住索引之间的一个间隙，不包含索引本身。


### 什么是乐观锁和悲观锁？

+ 悲观锁是先获取锁，再进行操作。一锁二查三更新。
+ 乐观锁是先进行操作，再获取锁。更新的时候发现数据已经变了就回滚。
+ 悲观锁适用于多写的场景，乐观锁适用于多读的场景。
+ 多写的场景指的是：写操作比较多，读操作比较少，这种情况下使用悲观锁可以保证数据的一致性。
+ 多读的场景指的是：读操作比较多，写操作比较少，这种情况下使用乐观锁可以提高性能。

### 死锁产生的条件以及如何解决？

+ 死锁产生的条件是：互斥、请求与保持、不可剥夺、循环等待。
+ 互斥：一个资源每次只能被一个进程使用。
+ 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
+ 不可剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。
+ 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。
+ 解决死锁的方法：
    + 预防死锁：破坏死锁产生的四个条件之一。
    + 避免死锁：银行家算法。
    + 检测死锁：检测到死锁后，撤销一些进程，从而解除死锁。
    + 解除死锁：撤销进程，剥夺资源。

### Mysql 常用的数据类型有哪些？

+ 数值类型：整型（int）、浮点型（float）、定点数（decimal）、双精度浮点型（double）、位类型（bit）。
+ 字符串类型：定长字符串（char）、变长字符串（varchar）、二进制字符串（binary）、变长二进制字符串（varbinary）、枚举类型（enum）、集合类型（set）。
+ 日期类型：日期（date）、时间（time）、日期时间（datetime）、时间戳（timestamp）、年（year）。
+ 其他类型：文本（text）、小文本（tinytext）、大文本（longtext）、二进制（blob）、大二进制（longblob）、JSON（json）。

### Mysql 常用的两种引擎是什么？

+ Mysql 常用的两种引擎是 InnoDB 和 MyISAM。
+ MyISAM 引擎不支持事务，而 InnoDB 支持事务。
+ MyISAM 引擎不支持外键，而 InnoDB 支持外键。
+ MyISAM 引擎不支持行级锁，而 InnoDB 支持行级锁。
+ 行级锁的意思是：当一个事务访问一行数据时，其他事务是不能访问该行数据的。

### 什么是左连接和右连接？

+ 左连接：左连接是以左表为基础的，左表中的全部数据都会显示出来，而右表中的数据只会显示符合条件的数据。
+ 右连接：右连接是以右表为基础的，右表中的全部数据都会显示出来，而左表中的数据只会显示符合条件的数据。
+ 左连接查询语句：`select * from 表1 left join 表2 on 表1.id = 表2.id`。
+ 右连接查询语句：`select * from 表1 right join 表2 on 表1.id = 表2.id`。

## mysql 索引

### 什么是索引？

+ 索引是一种特殊的文件（InnoDB 数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。
+ 索引是帮助 Mysql 高效获取数据的数据结构。
+ 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同的存储引擎具有不同的索引类型和实现，如：Mysql 的 MyISAM 和 InnoDB 存储引擎使用的索引就不一样。
+ Innodb 使用的是聚集索引，MyISAM 使用的是非聚集索引。聚集索引指的是按照每张表的主键构造一颗 B+ 树，同时叶子节点中存放的就是整张表的行记录数据，而非聚集索引指的是叶子节点不包含行记录的全部数据，而是包含相应的主键，这个主键实际上是指向数据所在的物理位置。
+ 索引可以包含一个或多个列，多个列可以叫做联合索引。
+ 索引分为唯一索引和非唯一索引，唯一索引的值必须唯一，但是可以有空值，非唯一索引的值可以不唯一，但是可以有空值。

### B+ 树查找时间复杂度

+ B+ 树是一种多路平衡查找树，它的每个节点最多包含 m 个孩子，m 被称为 B+ 树的阶，m 的大小取决于磁盘页的大小。
+ B+ 树的查找过程和二分查找类似，都是先取中间节点，然后根据比较结果决定向左还是向右查找，直到找到目标数据。
+ B+ 树的查找时间复杂度是 O(logn)。
+ B+ 树的插入、删除、更新时间复杂度也是 O(logn)。
+ B+ 树的插入、删除、更新操作都是在叶子节点进行的，所以 B+ 树的插入、删除、更新操作不会破坏树的结构，所以 B+ 树的插入、删除、更新操作不会引起树的重构。

### 索引应用和优化

+ 索引可以加快数据的检索速度，但是会降低数据的写入速度，因为每次写入数据的时候都要维护索引。
+ 索引可以加快数据的排序速度，但是会降低数据的插入速度，因为插入数据时，还要维护索引。
+ 索引的优化：
    + 索引列的选择：选择区分度高的列作为索引列。
    + 索引列的顺序：选择区分度高的列作为索引列，同时将区分度高的列放在前面。
    + 联合索引：选择区分度高的列作为索引列，同时将区分度高的列放在前面。
    + 覆盖索引：索引列包含了查询的字段，这样就不需要回表查询了。
    + 索引列的长度：索引列的长度越小，索引的高度越低，查询的速度越快。
    + 索引列的数据类型：索引列的数据类型越小，索引的高度越低，查询的速度越快。
    + 索引列的顺序：索引列的顺序要和查询条件的顺序一致，这样才能使用到索引。
    + 索引列的范围查询：尽量避免使用范围查询，因为范围查询无法使用到索引。
    + 索引列的 like 查询：尽量避免使用 like 查询，因为 like 查询无法使用到索引。
    + 索引列的 in 查询：尽量避免使用 in 查询，因为 in 查询无法使用到索引。
    + 索引列的 is null 查询：尽量避免使用 is null 查询，因为 is null 查询无法使用到索引。
    + 索引列的排序：尽量避免对索引列进行排序，因为排序会降低查询的速度。
    + 索引列的分组：尽量避免对索引列进行分组，因为分组会降低查询的速度。
    + 索引列的 join：尽量避免对索引列进行 join，因为 join 会降低

### 慢 sql 优化

+ 使用 explain 命令查看 sql 语句的执行计划，看看是否使用了索引。
+ 使用 show profile 命令查看 sql 语句的执行时间。
+ 使用 show status 命令查看数据库的一些状态信息，如：数据库的连接数、数据库的锁状态等。
+ 使用 show processlist 命令查看数据库的连接信息，如：连接的 id、连接的用户、连接的主机、连接的状态等。
+ 使用 show variables 命令查看数据库的一些配置信息，如：数据库的版本、数据库的字符集等。
+ 使用 show engine innodb status 命令查看数据库的 innodb 状态信息。

## redis

### redis 常用数据类型

+ String、Hash、List、Set、Sorted Set

### redis hash 数据类型有什么作用？

+ hash 数据类型是指一个 key 对应一个字典，字典中的 key 和 value 都是字符串。
+ hash 数据类型的应用场景是：存储对象、存储用户信息、存储商品信息等。

### redis 高可用方案？

### redis 持久化方案？

+ 因为 redis 是个内存数据库，为了确保数据的持久化，Redis 自身提供了两种持久化方案：
    1. RDB（Redis Database）持久化：
        + 一种快照持久化方式，定期将内存中的数据快照写入磁盘文件
        + 适用于数据集较大，备份不需要太频繁的情况
    1. AOF（Append-Only File）持久化：
        + 记录每个写操作（包括写、更新、删除操作）的日志文件，以文本文件形式追加到文件末尾
        + 当 Redis 重启时，可以通过重新执行AOF文件中的操作来还原数据
        + 适用于需要高可用性和数据完整性的场景
    1. 兼容 RDB 和 AOF 的混合持久化：
        + Redis 4.0 引入了混合持久化，结合了RDB和AOF的优点
        + 数据首先会被写入 AOF 文件，然后 AOF 文件会被重新加载到内存
        + 最后根据需要创建 RDB 快照

### redis 如何实现分布式锁？

+ 使用 setnx 命令，setnx 命令是 set if not exists 的缩写，也就是当 key 不存在时才设置 key 的值。
+ 可以同时通过 expire 添加超时时间。
+ 锁的 value 可以使用 uuid 等随机数，这样可以保证每个线程的锁都是唯一的。
+ 释放锁的时候通过 uuid 判断是否是自己的锁，如果是自己的锁才能释放。

### 缓存优化是什么？

+ 缓存优化是指通过缓存来提高系统的性能。
+ 缓存优化的原则是：缓存的数据必须是热点数据，缓存的数据必须是经常读取的数据。
+ 缓存优化的方式有：缓存预热、缓存穿透、缓存击穿、缓存雪崩。
+ 缓存预热：系统上线后，将相关的缓存数据直接加载到缓存系统。
+ 缓存穿透：查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
+ 缓存穿透问题解决：1、对查询结果为空的情况也进行缓存，缓存时间设置短一点。2、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
+ 缓存击穿：一个存在的 key，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
+ 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大的压力，可能会导致系统崩溃。

### Mysql 如何添加分区？添加分区有什么作用？

+ Mysql 添加分区的语法：`alter table 表名 add partition (partition 分区名 values in (分区值))`。
+ Mysql 分区表的作用：分区表是一种表结构，它的数据被分成多个分区，每个分区都包含表中的一些数据。分区表的作用是：提高查询效率、提高维护效率、提高可用性。
+ 区分热点数据和冷点数据，将热点数据放到热点分区中，将冷点数据放到冷点分区中，这样可以提高查询效率。

### Mysql 性能优化

+ 优化数据库的结构：优化数据库的表结构，如：添加索引、添加分区等。
+ 优化数据库的配置：优化数据库的配置，如：修改数据库的字符集、修改数据库的缓存大小等。
+ 优化数据库的查询：优化数据库的查询，如：优化 sql 语句、优化索引等。
+ 优化数据库的连接：优化数据库的连接，如：优化数据库的连接池、优化数据库的连接数等。
+ 优化数据库的缓存：优化数据库的缓存，如：优化 redis 的缓存、优化 memcached 的缓存等。
+ 优化数据库的硬件：优化数据库的硬件，如：优化数据库的磁盘、优化数据库的内存等。
