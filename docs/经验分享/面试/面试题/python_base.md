# Python 语言

## Python 语言基础

### 谈谈你认为的 Python 语言的优缺点

+ 胶水语言，轮子多，应用广泛。

+ 语言灵活，生产力高

+ 缺点是性能问题、代码维护问题、2/3 版本兼容问题。

### Python 是静态还是动态类型？是强类型还是弱类型？

+ 动态还是静态指的是变量的类型是在编译时确定还是在运行时确定。
+ Python 是动态类型语言，变量的类型是在运行时确定的。

+ 强类型还是弱类型指的是变量的类型转换是否受限制，会不会发生隐式类型转换。
+ Python 是强类型语言，不同类型的变量不能直接进行运算，需要进行类型转换。

### 什么是鸭子类型？

+ 有一句话是："如果你看到一只鸟，走起来像鸭子，游泳起来像鸭子，叫起来也像鸭子，那么这只鸟就可以被称为鸭子。"

+ 鸭子类型是一种动态类型的风格，是多态的一种形式。

+ 关注的是对象的行为，而不是对象的类型。

+ 常见的应用场景就是：Python 中的迭代器协议，只要对象实现了 `__iter__` 和 `__next__` 方法，那么这个对象就是可迭代的。

### 什么是 socket?

+ socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。

+ 在设计模式中，socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 socket 接口后面，对用户来说只需要调用 socket 接口就可以了。

+ Python 中提供了两个模块来支持 socket 实现，一个是 socket，一个是 asyncio 中的 transports 和 protocols。



### 什么是 monkey patch？

+ monkey patch 是指在运行时动态修改一个类或模块，即运行时替换。

    ```python
    import time
    print(time.time())

    def new_time():
        return 1234567890.0
    
    # monkey patch
    time.time = new_time
    print(time.time())
    ```

+ 比如 gevent 就是通过 monkey patch 来实现协程的。

    ```python
    import socket
    print(socket.socket)

    from gevent import monkey
    monkey.patch_socket()
    print(socket.socket)
    ```

### 什么是自省（introspection）？

+ 自省就是运行时判断一个对象类型的能力。
+ Python 中的自省机制包括：`id()`、`type()`、`isinstance()`、`dir()`、`hasattr()`、`callable()`、`issubclass()`。
+ Inspect 模块也提供了很多自省的函数。
+ 自省的应用场景：动态导入模块、动态实例化类、动态获取类的成员。

### 你知道 Python 之禅是什么吗？

+ Python 之禅是 Python 的设计哲学，是 Python 语言的核心。
+ 通过 `import this` 可以查看 Python 之禅。
+ 因为动态语言编写大型项目的可维护性不高，所以 Python 之禅强调的是可读性以及可维护性。

### 说几条 Python 之禅的内容？

+ 美胜于丑
+ 明了胜于晦涩
+ 简洁胜于复杂
+ 复杂胜于凌乱

## Python 2 and Python3

### Python 2 和 Python 3 的区别

+ Python 2 默认编码是 ASCII，Python 3 默认编码是 UTF-8

+ Python 2 的 print 是一个语句，Python 3 的 print 是一个函数

+ Python 2 的整数除法是向下取整返回一个整型，Python 3 的整数除法是向零取整返回一个浮点型

### Python 3 的改进

+ 提供了很多方便的语法糖，比如解包、类型注解

+ 内置函数之前返回列表的现在全部返回为迭代器，节省了内存

+ 提供了异步编程的支持

### 兼容 2/3 版本的工具

+ six 模块，提供了语法兼容工具
+ 2to3 工具，可以将 Python 2 代码转换为 Python 3 代码
+ __future__ 模块，可以在 Python 2 中使用 Python 3 的特性

## Python 3 基础

### 什么是 GIL 吗？

+ GIL 是 Python 解释器的全局解释器锁，它保证了同一时刻只有一个线程在执行 Python 字节码。
+ 由于 GIL 的存在，Python 解释器在执行多线程代码的时候，同一时刻只能有一个线程在执行，所以 Python 的多线程是伪多线程。
+ 前段时间也有说法指出 python 官方已经考虑去除 GIL.

1. GIL 不是 python 的特点，而是 Cpyhton 的特点
2. GIL 保证的是解释器级别的数据安全
	Cpython 中内存管理不是线程安全的，如果不加互斥锁，在给变量赋值的时候，有可能垃圾回收机制也在工作，导致错误
3. 同一进程下多线程无法同时运行，无法利用多核优势，但可以快速切换，伪多线程
4. 解释型语言的通病
5. 针对不同的数据还是要加不同的锁处理(自己加锁是为了避免由于阻塞而自动切换线程)
+ 注释：GIL 本质就是给 python 解释器加了锁，使得线程间只能串行，保证了数据内存的安全

### Python 中的多线程和多进程有什么区别？

+ 多线程是指在同一进程中，有多个线程同时执行，而多进程是指有多个进程同时执行。

+ 多线程之间共享进程的内存空间，而多进程之间不共享内存空间。

+ 多线程之间的切换不会引起系统的上下文切换，而多进程之间的切换会引起系统的上下文切换。

+ 系统的上下文切换指的是：CPU 从一个进程切换到另一个进程时，需要保存当前进程的状态，然后加载新进程的状态，这个过程就是系统的上下文切换。

+ 多线程之间的切换不会引起进程的内存空间的切换，而多进程之间的切换会引起进程的内存空间的切换。

+ 多线程之间的切换速度比多进程之间的快。

+ 多线程之间的通信方式有：共享变量、队列、管道、共享内存、信号量、套接字等。多进程之间的通信方式有：队列、管道、共享内存、套接字等。

### 协程是什么，python 是如何实现的？

+ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
+ 协程的本质是一个线程，所以协程之间的切换不会引起系统的上下文切换，协程之间的切换只会引起用户态的上下文切换。

+ 协程的实现方式有：yield、generator、asyncio 等。

    ```python
    def func():
        print('start')
        yield
        print('end')
    
    g = func()
    next(g)  # start
    next(g)  # end
    ```
    
    ```python
    import asyncio
    async def func():
        print('start')
        await asyncio.sleep(1)
        print('end')

    asyncio.run(func())  # start
    ```

### 什么是 Python 中的魔法方法？

+ 魔法方法是指 Python 中的一些特殊方法，这些方法的特点是：方法名前后都有两个下划线。
+ 魔法方法的作用是：实现类似于运算符的功能，比如 `__add__` 方法实现了 `+` 运算符的功能。
+ 魔法方法的应用场景有：运算符重载、属性访问控制、对象初始化、对象销毁、迭代器协议等。


### 什么是 Python 中的迭代器协议？

+ 迭代器协议是指对象需要提供一个 `__iter__` 方法，该方法返回一个迭代器对象，迭代器对象需要提供一个 `__next__` 方法，该方法返回迭代器中的下一个元素。
+ 迭代器协议的应用场景有：for 循环、列表推导式、生成器表达式、in、map、filter、sum、min、max、sorted、reversed、zip、enumerate 等。
+ 迭代器协议的实现方式有：类实现、生成器函数实现、生成器表达式实现。

### 垃圾回收机制

+ 垃圾回收机制应用在内存管理中，用于回收不再使用的内存空间。一句话总结就是：**引用计数器** 为主，**标记清除** 和 **分代回收** 为辅。

+ 引用计数器：Python 3 使用了引用计数机制来跟踪内存中的对象，即每个对象创建时都有一个引用计数 refcnt，当对象被引用时，它的引用计数加 1，当对象不被引用时，它的引用计数减 1，当对象的引用计数为 0 时，它就会被垃圾回收机制回收。

+ 标记清除：主要是为了解决对象之间相互引用，导致引用计数不为 0 的情况。主要的实现方式是通过遍历以 root 为节点的有向图，如果一个对象入度为 0，那么它就是循环引用的一部分，就应该将其回收。

+ 分代回收：主要是为了解决回收机制的性能问题，控制回收的频次，是一种以时间换空间的操作方式。指的是将对象分为三代，新创建的对象为第 0 代，当第 0 代对象经过一次垃圾回收后，如果没有被回收，那么它就会被提升为第 1 代，以此类推，当第 2 代对象经过一次垃圾回收后，如果没有被回收，那么它就会被提升为第 3 代，第 3 代对象不会再被提升，当第 3 代对象经过一次垃圾回收后，如果没有被回收，那么它就会被放入到一个不可回收的列表中。

+ 分代回收中有一个阈值机制，当垃圾回收器检测到第 0 代对象的数量达到了阈值，那么就会执行一次垃圾回收，当垃圾回收器检测到第 1 代对象的数量达到了阈值，那么就会执行一次垃圾回收，以此类推。

    ```python
    import gc

    print(gc.get_threshold())  # 默认值 (700, 10, 10)
    gc.set_threshold(700, 10, 10)  # 设置阈值
    ```

### 字典的合并有哪几种方法？

+ 使用 `update()` 方法

    ```python
    d1 = {'a': 1, 'b': 2}
    d2 = {'c': 3, 'd': 4}
    d1.update(d2)
    print(d1)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    ```

+ 使用 `**` 运算符

    ```python
    d1 = {'a': 1, 'b': 2}
    d2 = {'c': 3, 'd': 4}
    d3 = {**d1, **d2}
    print(d3)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    ```

+ 使用 `ChainMap` 类

    ```python
    from collections import ChainMap

    d1 = {'a': 1, 'b': 2}
    d2 = {'c': 3, 'd': 4}
    d3 = ChainMap(d1, d2)
    print(d3)  # ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4})
    ```

+ 使用 `dict()` 函数

    ```python
    d1 = {'a': 1, 'b': 2}
    d2 = {'c': 3, 'd': 4}
    d3 = dict(d1, **d2)
    print(d3)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    ```

+ 使用 3.9 版本中提供 `|` 方法

    ```python
    d1 = {'a': 1, 'b': 2}
    d2 = {'c': 3, 'd': 4}
    d3 = d1 | d2
    print(d3)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    ```

+ 注：以上只有 update 会修改原字典，其他方法都不会修改原字典。可以使用 copy 方法来复制字典。

### deepcopy 和 copy 的区别？

+ copy 浅拷贝，只拷贝父对象，不会拷贝对象的内部的子对象。

+ deepcopy 深拷贝，拷贝对象及其子对象。

+ 相当于 copy 拷贝的是对象的引用，而 deepcopy 拷贝的是对象的值。

## Python 函数

### 什么是 Python 中的可变对象和不可变对象

+ 可变对象：列表、字典、集合、自定义类
+ 不可变对象：数字、字符串、元组、布尔值、None、frozenset、bytes

+ Python 中一切皆对象，变量是对象的引用。可变对象作为参数传递时，传递的是对象的引用，所以在函数内部修改了可变对象，会影响到函数外部的对象。不可变对象作为参数传递时，传递的是对象的值，所以在函数内部修改了不可变对象，不会影响到函数外部的对象，并且生成了一个新的对象。

### Python 中 *args 和 **kwargs 的作用

+ *args：将位置参数打包成 tuple 给函数体调用，可以通过列表或元组解包的方式传递位置参数给函数
+ **kwargs：将关键字参数打包成 dict 给函数体调用，可以通过字典解包的方式传递关键字参数给函数

### 装饰器主要实现逻辑

+ 装饰器的本质是一个函数，它接收一个函数作为参数，然后返回一个函数。

+ 装饰器的作用是在不改变原函数的情况下，为原函数添加新的功能。

+ 实现代码如下：

    ```python
    def decorator(func):
        def wrapper(*args, **kwargs):
            # do something
            return func(*args, **kwargs)
        return wrapper

    @decorator
    def func():
        pass
    ```

## Python 异常

### Python 中的异常处理机制

+ Python 中的异常处理机制是 try-except-else-finally 语句。

### 为什么自定义异常通常是继承 Exception 而不是继承 BaseException

+ BaseException 是所有内置异常的基类，而 Exception 是所有内置非系统退出异常的基类。

+ 自定义异常通常是继承 Exception，因为 BaseException 包含了系统退出异常，如果自定义异常继承 BaseException，那么这个自定义异常就会被系统退出异常捕获，从而导致程序退出。

```python
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ...
```

