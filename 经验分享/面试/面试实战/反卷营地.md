## 简介

大语言模型 前后端 中间层

模型组：人比较多 70/80 人
前后端：目前没人，从零开始


主要团队在美国

居家办公

---

## 面试题

### 你所做的项目里面的技术难点？

+ 在线判题项目主要有两个难点吧？一个是安全问题，另一个是定时任务问题。
+ 安全问题主要面临用户提交代码，服务端要运行代码可能存在的注入问题。当时使用了 docker 去做代码沙箱安全方案，使用 docker 容器为每个用户提交的代码创建了一个独立的容器，实现隔离。
+ 定时任务是因为项目中涉及比赛报名开始和截至，比赛运行开始和截至等。使用的 celery 做的定时任务方案。

### 你的项目上线了吗？

+ 是的，我的项目曾经上线过。在初期阶段，我们成功地将项目部署到线上环境，并确保其正常运行。
+ 然而，鉴于当前的项目阶段和需求，我们决定将其暂时下线。这并不是因为项目出现了问题，而是因为目前没有持续上线的紧迫需要。
+ 我们已经建立了自动化的 Docker 部署环境，以确保将来可以轻松地重新上线，实现更灵活的部署和管理。

### 如果服务器通过 docker 判题，如何保证性能？你考虑的最大并发量是多少？

+ 我自己在考虑该项目的并发量的时候，最大业务并发用户数大概为 100，判题接口的并发量为 50。因为本身是个毕业设计项目，没有考虑上线后的规模问题，所以在第一次部署，采用的是阿里云学生服务器，我没记错应该是 2核，2G，1M 带宽。虽然没有进行系统的压力测试，但是多个人同时访问和使用都是没问题的。我自己当时预估的是 50 左右。
+ 判题接口的优化主要有几个方面：一是通过异步任务也就是 celery 框架处理这个耗时任务。二是针对 docker 每个容器做了资源上限，因为每个算法提交代码大致资源都有一个标准，提前通过数据库存储每道题需要的 docker 资源标准，在执行时做好 docker 的资源上限。第三就是容器复用，尽可能地重用已创建的容器，以避免频繁地创建和销毁容器的开销。Docker 的容器是轻量级的，但启动和停止仍然有一些开销。第四是数据库优化，如果判题系统涉及数据库操作，确保数据库的索引、查询和连接池等方面进行了优化。

### 有什么量化数据来体现你做过的需求效果比较好？

+ 是这样的，由于是产品线的迭代版本功能，是提供给已购买产品用户的增值服务，所以这个数据衡量可以从两方面侧面体现出，一是新版本推出后的，增加了产品的优势，吸引到了更多客户，二是原有客户对新功能普遍比较满意。
+ 因为我做的只是迭代版本的其中一些需求，所以没有针对单个需求量化统计，但是因为公司业务增长，所以该季度绩效提升。

### 你们公司产品支持的最大并发量是多少？

+ 因为我们产品售卖后是在客户本地环境进行单机部署，本质是一套管理系统，所以本身业务上并发量和吞吐量没有那么高要求。

### 非关系型数据库和关系型数据库的区别是什么？

+ 数据模型：
    + 关系型数据库：使用表格（表）和行的结构来组织数据。数据被组织成结构化的表，表之间通过关系进行连接。
    + 非关系型数据库：使用不同的数据模型，包括文档型、键值对、列族型和图形型等。非关系型数据库可以更灵活地存储和检索非结构化或半结构化的数据。
+ 架构设计：
    + 关系型数据库：遵循ACID（原子性、一致性、隔离性、持久性）原则，确保数据的一致性和完整性。通常采用固定的模式，需要预定义表的结构。
    + 非关系型数据库：更灵活，可能牺牲一些ACID属性以换取更好的可扩展性和性能。常用BASE（基本可用、柔性状态、最终一致性）作为一致性模型。
+ 数据一致性：
    + 关系型数据库：通过事务保持强一致性，事务要么全部执行成功，要么全部失败，保持数据库的一致性。
    + 非关系型数据库：可能采用 eventual consistency（最终一致性）模型，即在一定时间内系统将达到一致状态，但不要求实时一致性。
+ 扩展性：
    + 关系型数据库：垂直扩展（增加更强大的硬件）相对容易，但水平扩展（通过添加更多节点）相对困难。
    + 非关系型数据库：通常设计为能够水平扩展，通过添加更多节点来增加存储和处理能力。
+ 适用场景：
    + 关系型数据库：适用于需要强一致性、事务处理和复杂查询的场景，例如金融系统、企业管理系统等。
    + 非关系型数据库：适用于需要高可扩展性、灵活的数据模型和大量读写操作的场景，例如社交媒体、日志记录、实时分析等。

### MySQL 支持的最大并发量是多少？

+ 8核 16G 的数据库大体是几千个数量级。
+ 优化：读写架构分离、热冷点数据、同步到缓存。

### python 协程底层实现的原理？

+ 在 Python 中，协程的底层实现主要依赖于生成器和事件循环的概念。我们使用 async def 来定义异步函数，内部使用 await 来挂起执行，而事件循环则负责调度协程的执行。
+ 生成器的特性允许我们在函数执行期间暂停并保持状态，然后在需要时继续执行，这就是协程能够实现非阻塞异步操作的关键。整个过程让我们能够更有效地处理异步 I/O 操作，提高程序的性能。

### python 有线程为什么还要协程呢？

+ 第一是轻量性：相比于线程，协程的切换不需要涉及操作系统的系统调用，线程是操作系统级别的调度单元，相对较重量级。
+ 第二是无需锁：在多线程编程中，由于线程间共享内存空间，可能涉及到对共享数据的加锁操作以保证数据的一致性。这种锁机制在并发场景下可能导致死锁和性能问题。协程通过避免共享状态，减少了对锁的需求，简化了并发编程。
+ 第三是适用于I/O密集型任务：协程特别适用于 I/O 密集型任务，例如网络请求、文件读写等。在这些任务中，线程可能会因为等待 I/O 操作完成而被阻塞，浪费了系统资源。而协程可以在等待期间主动让出控制权，执行其他任务，提高了并发效率。
+ 第四是单线程执行：协程运行在单线程中，避免了多线程编程中的竞争条件和并发控制问题。虽然 Python 中的全局解释器锁（GIL）会限制多线程的并行执行，但协程在单线程内的执行不受 GIL 的限制，因此能够更好地利用系统资源。

### python 一个协程卡死，会影响其他的协程吗？

+ 当一个协程卡死时，它确实会占用系统资源，但并不会影响到其他协程的执行。这是因为协程是在线程下的，属于用户态，操作系统对协程是无感知的。在线程内的多个协程是通过协程的调度获得CPU时间的，所以它们是串行的。也就是说，当线程下的某个协程在运行时，其他协程会被挂起，没有在运行。但是需要注意的是，如果这个卡死的协程持有了其他协程需要的资源，那么这些协程可能会受到影响。因此，我们需要在编写协程代码时注意避免无限循环或递归调用，合理使用异常处理机制，以及定期检查协程状态，及时终止卡死的协程。

### tcp 和 udp 区别？

+ TCP和UDP是两种不同的网络传输协议。它们的主要区别可以从以下几个方面进行阐述：
1. 连接方式：TCP是一种面向连接的协议，这意味着在传输数据之前需要先建立一条专用的通信连接。而UDP则不需要建立这样的连接，可以直接发送和接收数据。
1. 服务对象：TCP是一对一的两点服务，即一条连接只有两个端点。相比之下，UDP支持一对一、一对多、多对多的交互通信。
1. 可靠性：TCP致力于可靠地交付数据，保证数据可以无差错、不丢失、不重复、按需到达。然而，UDP的交付机制是尽最大努力交付，无法保证数据的可靠交付。
1. 应用场景：TCP和UDP的使用场景是不同的。TCP适用于对数据传输可靠性要求较高的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高的场景，如语音通话、视频直播等。

### tcp 怎么保证可靠传输的？

TCP，作为一种面向连接的传输层协议，提供了全双工逻辑通信信道，能够保证端到端的可靠性传输。可靠传输意味着通过TCP连接传送的数据是没有差错、不会丢失、不重复并且按序到达的。

要实现这一目标，TCP主要依赖以下几个关键技术：

1. 序列号：TCP会为每个字节分配一个序列号，这样接收方就能够按照正确的顺序重组数据。
1. 检验和：TCP会对每个字节进行校验，以便检测出数据传输过程中可能出现的错误。
1. 确认应答信号：接收方在收到数据后会发送一个确认应答信号，以通知发送方数据已经成功接收。
1. 重发机制：如果发送方没有收到来自接收方的确认应答信号，那么它会对数据进行重新发送。
1. 连接管理：TCP会跟踪哪些数据已经被发送和接收，哪些还在等待发送或接收，从而确保数据的有序性和完整性。
1. 窗口控制：TCP可以通过调整发送窗口的大小来优化网络资源的使用。

### http 和 https 的区别？

+ HTTPS则在HTTP协议的基础上，通过SSL/TLS加密协议在应用层和传输层之间添加了一层安全层，保证了数据传输的安全性。
+ HTTP使用明文方式传输数据，这种方式下，数据容易被截获和篡改。相反，HTTPS会对数据进行加密处理，从而防止敏感信息被第三方获取。
+ HTTP使用明文方式传输数据，这种方式下，数据容易被截获和篡改。相反，HTTPS会对数据进行加密处理，从而防止敏感信息被第三方获取。
+ HTTPS协议需要到CA机构申请证书，大部分免费的证书很少，通常需要支付一定的费用。在这个过程中，Web服务器需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。

### http 的 get 和 post 的区别？

GET 和 POST 是 HTTP 请求方法，它们在数据传输方式、数据传输大小限制、安全性、幂等性和缓存等方面有一些不同。

+ GET 请求将数据附加在 URL 中，适合传输小量的非敏感信息，而 POST 请求将数据放在请求体中，适合传输大量或敏感信息。
+ GET 是幂等的，而 POST 不是幂等的，可能产生不同的结果。
+ 此外，GET 可以被浏览器缓存，而 POST 不容易被缓存。

### vue 双向绑定的底层原理是什么？


+ Vue 双向绑定的底层原理主要包括数据劫持、Getter 和 Setter、发布-订阅模式，以及虚拟 DOM 的应用。
+ 通过使用 Object.defineProperty 对数据进行劫持，为每个属性添加 getter 和 setter，实现数据的监听。
+ Getter 负责依赖收集，Setter 负责触发更新，通过发布-订阅模式确保数据变化时通知所有依赖的 Watcher 进行更新。
+ 引入虚拟 DOM 的概念，通过对比新旧虚拟 DOM 树的差异，最小化更新范围，提高性能。
+ 在具体实现中，v-model 是双向绑定的体现，通过对输入框的事件监听和值的动态绑定，实现数据和视图的双向同步。这些原理的结合使得 Vue 能够实现数据和视图之间的实时同步，提升开发效率。
